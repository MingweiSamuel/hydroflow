<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hydroflow Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">1.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="example_1.html"><strong aria-hidden="true">1.2.</strong> Simplest Example</a></li><li class="chapter-item expanded "><a href="example_2.html"><strong aria-hidden="true">1.3.</strong> Simple Example</a></li><li class="chapter-item expanded "><a href="example_3.html"><strong aria-hidden="true">1.4.</strong> A Example With Streaming Input</a></li><li class="chapter-item expanded "><a href="example_4.html"><strong aria-hidden="true">1.5.</strong> Graph Reachability</a></li><li class="chapter-item expanded "><a href="example_5.html"><strong aria-hidden="true">1.6.</strong> Graph Un-Reachability</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="in-out_trees.html"><strong aria-hidden="true">3.1.</strong> Subgraph In-Out Trees</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hydroflow Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/hydro-project/hydroflow">Hydroflow</a> is a dataflow runtime
written in Rust, serving as the execution layer of the <a href="https://hydro-project.github.io/">Hydro stack</a>.
This book teaches how to set up and get started with Hydroflow.</p>
<p>Keep in mind that Hydroflow is under active development and is constantly
changing. However this book is tested in CI so should always be up-to-date
(though incomplete, for now).</p>
<p>If you have any questions, feel free to <a href="https://github.com/hydro-project/hydroflow/issues/new">create an issue on Github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>This section will get you up and running with Rust and Hydroflow without
worrying too much about the tricky details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This section explains how to get Hydroflow running, either for development or
usage, even if you are not familiar with Rust development.</p>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>First you will need to install Rust. We recommend the conventional installation
method, <code>rustup</code>, which allows you to easily manage and update Rust versions.</p>
<p><a href="https://www.rust-lang.org/tools/install"><strong>Install Rust</strong></a></p>
<p>This will install <code>rustup</code> and the Rust package manager <code>cargo</code> (and the
internally-used <code>rustc</code> compiler). <code>cargo</code> is Rust's main development tool,
used for building, running, and testing Rust code.</p>
<p>The following <code>cargo</code> commands will come in handy:</p>
<ul>
<li><code>cargo check --all-targets</code> - Checks the workspace for any compile-time
errors.</li>
<li><code>cargo build --all-targets</code> - Builds all projects/tests/benchmarks/examples
in the workspace.</li>
<li><code>cargo clean</code> - Cleans the build cache, sometimes needed if the build is
acting up.</li>
<li><code>cargo test</code> - Runs tests in the workspace.</li>
<li><code>cargo run -p hydroflow --example &lt;example name&gt;</code> - Run an example program in
<code>hydroflow/examples</code>.</li>
</ul>
<p>To learn Rust see the official <a href="https://www.rust-lang.org/learn">Learn Rust page</a>.
Here are some good resources:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em>, AKA &quot;The Book&quot;</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a>
is a good way to learn Rust's ownership system and its
implications.</li>
</ul>
<h2 id="vs-code-setup"><a class="header" href="#vs-code-setup">VS Code Setup</a></h2>
<p>We recommend using VS Code with the <code>rust-anaylzer</code> extension (and NOT the
<code>Rust</code> extension). To enable the pre-release version of <code>rust-analyzer</code>
(required by some new nightly syntax we use, at least until 2022-03-14), click
the &quot;Switch to Pre-Release Version&quot; button next to the uninstall button.</p>
<h2 id="hydroflow-setup"><a class="header" href="#hydroflow-setup">Hydroflow Setup</a></h2>
<p>The easiest way to get started with Hydroflow is to clone and work in the
repository directly. You should fork the repository if you want to push your
changes.</p>
<pre><code class="language-bash">git clone git@github.com:hydro-project/hydroflow.git
</code></pre>
<p>Hydroflow requires nightly Rust, but the repo is already configured for it via
<code>rust-toolchain.toml</code>.</p>
<p>We can then open the repo in VS Code or IDE of your choice. <code>rust-anaylzer</code>
will provide inline type and error messages, code completion, etc.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<p>The easiest way to try Hydroflow is with an &quot;example&quot;, found in the
<a href="https://github.com/hydro-project/hydroflow/tree/main/hydroflow/examples"><code>hydroflow/examples</code> folder</a>.
These examples are include via the <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/Cargo.toml"><code>hydroflow/Cargo.toml</code> file</a>,
so make sure to add your example there if you create a new one. The simplest
example is <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/examples/graph_reachability/main.rs"><code>graph_reachability</code></a>.</p>
<p>The Hydroflow repository is set up as a <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">workspace</a>,
i.e. a repo containing a bunch of separate packages, <code>hydroflow</code> is just the
main one. So if you want to work in a proper separate cargo package, you can
create one and add it into the <a href="https://github.com/hydro-project/hydroflow/blob/main/Cargo.toml">root <code>Cargo.toml</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplest-example"><a class="header" href="#simplest-example">Simplest Example</a></h1>
<p>Lets start out with the simplest possible Hydroflow program, which prints out
the numbers in <code>0..10</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::builder::prelude::*;

pub fn main() {
    let mut builder = HydroflowBuilder::new();
    builder.add_subgraph(
        &quot;main&quot;,
        (0..10)
            .into_hydroflow()
            .pull_to_push()
            .for_each(|n| println!(&quot;Hello {}&quot;, n)),
    );

    let mut hydroflow = builder.build();
    hydroflow.tick();
}
</code></pre></pre>
<p>And the output:</p>
<pre><code class="language-txt">Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
Hello 5
Hello 6
Hello 7
Hello 8
Hello 9
</code></pre>
<p>Although this is a trivial program, there's quite a bit going on that might
phase you. Let's go line by line.</p>
<pre><code class="language-rust ignore">use hydroflow::builder::prelude::*;
</code></pre>
<p>This is a prelude import: a convention where all the important dependencies are
re-exported in a single <code>prelude</code> module for convenience. In this case it's
everything you need for using Hydroflow via the <a href="./architecture.html#apis">Surface API</a>.
You can check <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/prelude/index.html">Hydroflow's rustdocs</a>
to see what exactly is imported.</p>
<p>Next, inside the main method we create a new <code>HydroflowBuilder</code>:</p>
<pre><code class="language-rust ignore">pub main() {
    let mut builder = HydroflowBuilder::new();
    builder.add_subgraph(
        &quot;main&quot;,
        // &lt;code for creating the subgraph&gt;
    );
    // ...
}
</code></pre>
<p>And add a subgraph. We are required to give the subgraph a name, in this case
<code>&quot;main&quot;</code>. The &quot;code for creating the subgraph&quot; is:</p>
<pre><code class="language-rust ignore">        (0..10)
</code></pre>
<p>This creates a Rust <a href="https://doc.rust-lang.org/std/ops/struct.Range.html"><code>Range</code> iterator</a>.</p>
<pre><code class="language-rust ignore">            .into_hydroflow()
</code></pre>
<p>Converts a Rust <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>
for use in Hydroflow via the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/trait.IntoHydroflow.html"><code>IntoHydroflow</code></a>
trait.</p>
<pre><code class="language-rust ignore">            .pull_to_push()
</code></pre>
<p>This line is specific to Hydroflow and a bit unusual. It converts the chain
from <em>pull</em> into <em>push</em> which allows us to use push-based methods:</p>
<pre><code class="language-rust ignore">            .for_each(|n| println!(&quot;Hello {}&quot;, n)),
</code></pre>
<p>Which consumes each element, printing it out as they arrive.</p>
<p>For now, all we need to know is that every Hydroflow subgraph starts as <em>pull</em>,
then becomes <em>push</em> after we call <code>.pull_to_push()</code>. Some operators can only be
used in the pull side, some can only be used in the push side, and some can be
used in either. The reason behind having separate pull and push-based operators
is explained in the <a href="./architecture.html#compiled-layer">Architecture</a> section.</p>
<p>Note that these chained method operators do not run any immediate
computations. Instead they provide a blueprint of what the Hydroflow graph
should look like.</p>
<pre><code class="language-rust ignore">    let mut hydroflow = builder.build();
    hydroflow.tick();
</code></pre>
<p>Finally we build the <code>Hydroflow</code> instance and run it via the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.tick"><code>tick()</code> method</a>.
Note that <code>tick()</code> runs the Hydroflow graph until no more work is immediately
available. In this case running the graph drains the iterator completely, so no
more work will ever be available. But once we add in external inputs such as
network ingress then more work might appear later. The <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.tick_stratum"><code>tick_stratum()</code></a>,
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run"><code>run()</code></a>
and [<code>run_async()</code>] https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_async
methods provide other ways to execute the graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h1>
<p>Lets build on the simplest example to explore some of the operators available
in Hydroflow. You may be familiar with operators such as <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.BaseSurface.html#method.map"><code>.map(...)</code></a>,
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.BaseSurface.html#method.filter"><code>.filter(...)</code></a>,
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.BaseSurface.html#method.flatten"><code>.flatten(...)</code></a>,
etc. from Rust iterators or from other programming languages, and these are
also available in Hydroflow.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::builder::prelude::*;

pub fn main() {
    let mut builder = HydroflowBuilder::new();
    builder.add_subgraph(
        &quot;main&quot;,
        (0..10)
            .into_hydroflow()

            .map(|n| n * n)
            .filter(|&amp;n| n &gt; 10)

            .pull_to_push()

            .map(|n| (n..=n+1))
            .flatten()

            .for_each(|n| println!(&quot;Howdy {}&quot;, n)),
    );

    let mut hydroflow = builder.build();
    hydroflow.tick();
}
</code></pre></pre>
<p><code>.map()</code> transforms each element one-to-one as it flows through the subgraph.
In this case, we square each number. Then <code>.filter()</code> only keeps any squared
numbers which are greater than 10.</p>
<p>After the pull to push. <code>.map()</code> converts each number into a
<a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html"><code>RangeInclusive</code></a>
of it and the next number. We then call <code>.flatten()</code> to conver the range
iterators into the numbers which they contains.</p>
<p>We can also express the same program with the combination operators
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.BaseSurface.html#method.filter_map"><code>.filter_map()</code></a>
and <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.BaseSurface.html#method.flat_map"><code>.flat_map()</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::builder::prelude::*;

pub fn main() {
    let mut builder = HydroflowBuilder::new();
    builder.add_subgraph(
        &quot;main&quot;,
        (0..10)
            .into_hydroflow()
            .filter_map(|n| {
                let n2 = n * n;
                if n2 &gt; 10 {
                    Some(n2)
                }
                else {
                    None
                }
            })
            .pull_to_push()
            .flat_map(|n| (n..=n+1))
            .for_each(|n| println!(&quot;G'day {}&quot;, n)),
    );

    let mut hydroflow = builder.build();
    hydroflow.tick();
}
</code></pre></pre>
<p>Note all of these operators work on both pull and push sides of a subgraph.
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.BaseSurface.html#"><code>BaseSurface</code></a>
contains the full list of such operators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-example-with-streaming-input"><a class="header" href="#an-example-with-streaming-input">An Example With Streaming Input</a></h1>
<p>In this example we'll introduce the concept of handoffs and external inputs.</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::builder::prelude::*;

pub fn main() {
    let mut builder = HydroflowBuilder::new();

    // code will go here

    let mut hydroflow = builder.build();
    hydroflow.tick();
}
</code></pre></pre>
<p>We'll start out with the above boilerplate. To add a new external input
channel, we can call the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/struct.HydroflowBuilder.html#method.add_channel_input"><code>builder.add_channel_input()</code></a>
method. The method requires several type parameters as well as a human-friendly
name for debugging, and returns a tuple of an input for feeding in items and a
output for receiving items into the subgraph.</p>
<pre><code class="language-rust ignore">let (input_example, example_recv) =
    builder.add_channel_input::&lt;_, Option&lt;usize&gt;, VecHandoff&lt;usize&gt;&gt;(
        &quot;My example input&quot;
    );
</code></pre>
<p>The Rust <code>::&lt;_, Option&lt;usize&gt;, VecHandoff&lt;usize&gt;&gt;</code> syntax is affectionately
called the &quot;turbofish&quot; and is how type parameters (generic arguments) are
supplied to generic types and functions. In this case the first type argument
is the label type, and by supplying an underscore <code>_</code> we leave it up to the
compiler to infer the type. The second and third type parameters are more
important.</p>
<p>The second type parameter, <code>Option&lt;usize&gt;</code>, specifies what we will be sending
into the input channel. Even though the input will be for <code>usize</code>s, we specify
<code>Option</code>s instead. This extra layer of abstraction allows us to pass in both
individual elements (via <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a>
or <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/lang/collections/struct.Single.html"><code>Single</code></a>)
or full iterators via <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/lang/collections/struct.Iter.html"><code>Iter</code></a>.</p>
<p>This syntax is a little verbose and clunky, and is subject to change in the
future.</p>
<p>Finally, the third type parameter is the <em>handoff</em> type. A handoff is a buffer
which stores elements as they wait to be processed. Handoffs are mainly used as
buffers between subgraphs, but in this case it is used to store the external
inputs until the subgraph is ready to process them.
Currently <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/handoff/struct.VecHandoff.html"><code>VecHandoff&lt;T&gt;</code></a>
is the main and only handoff type, but in the future we may implement more
specialized handoffs.</p>
<p>The returned <code>example_recv</code> value can be chained on the build a Hydroflow
subgraph just like before. Here is the same program as before, but using the
input channel:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::builder::prelude::*;

pub fn main() {
    let mut builder = HydroflowBuilder::new();

    // Create our channel input.
    let (input_example, example_recv) =
        builder.add_channel_input::&lt;_, Option&lt;usize&gt;, VecHandoff&lt;usize&gt;&gt;(
            &quot;My example input&quot;
        );

    builder.add_subgraph(
        &quot;main&quot;,
        example_recv
            .flatten() // Huh?!
            .map(|n| n * n)
            .filter(|&amp;n| n &gt; 10)
            .pull_to_push()
            .flat_map(|n| (n..=n + 1))
            .for_each(|n| println!(&quot;Ahoj {}&quot;, n)),
    );

    let mut hydroflow = builder.build();

    println!(&quot;A&quot;);
    input_example.give(Some(0));
    input_example.give(Some(1));
    input_example.give(Some(2));
    input_example.give(Some(3));
    input_example.give(Some(4));
    input_example.give(Some(5));
    input_example.flush();

    hydroflow.tick();

    println!(&quot;B&quot;);
    input_example.give(Some(6));
    input_example.give(Some(7));
    input_example.give(Some(8));
    input_example.give(Some(9));
    input_example.flush();

    hydroflow.tick();
}
</code></pre></pre>
<pre><code class="language-txt">A
Ahoj 16
Ahoj 17
Ahoj 25
Ahoj 26
B
Ahoj 36
Ahoj 37
Ahoj 49
Ahoj 50
Ahoj 64
Ahoj 65
Ahoj 81
Ahoj 82
</code></pre>
<p>At the bottom we can see supplying inputs with <code>.give(Option)</code>. And
importantly, make sure to call <code>.flush()</code>!</p>
<p>Unlike the previous example, there's an extra <code>.flatten()</code> directly after
starting with <code>example_recv</code>. This is because the handoff actually returns its
entire buffer as one element (a <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque&lt;T&gt;</code></a>)
rather than returning each element individually. This lets us process the data
as a batch if needed, but most of the time we'll just call <code>.flatten()</code> to
convert back into individual elements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-reachability"><a class="header" href="#graph-reachability">Graph Reachability</a></h1>
<p>So far all the operators we've used have one input and one output and therefore
create a linear graph. Let's now take a look at a Hydroflow program containing
a subgraph which has multiple inputs and outputs.
To motivate this, we'll tackle the simple problem of graph reachability. Given
a graph in the form of a streaming list of edges, which vertices can be reached
from the origin vertex?</p>
<p>It turns out this is very naturally represented as a dataflow program. We take
our initial starting vertex and join it with all its outgoing edges to get a
vertices one hop away. Then we join that set of vertices with the edges again
to get reachable vertices two hops away. If we repeat this in a loop we quickly
find all reachable vertices.</p>
<!-- Note about monotonicity? -->
<p>Here is a diagram of that dataflow program:</p>
<pre class="mermaid">graph TD
  subgraph Subgraph
    00[Initial Vertex]
    01[Edges Input]
    10[\Reached Vertices/]
    20(&quot;V ⨝ E&quot;)
    30[/Reached Vertices\]
    40[Output]

    00 --&gt; 10
    10 --&gt; 20
    20 --&gt; 30
    30 ----&gt; 10

    01 ---&gt; 20
    30 --&gt; 40
  end
</pre>
<p>This dataflow program has a few interesting features including nodes with
multiple inputs or outputs as well as a loop. To represent this, we'll need to
know a bit more about <em>pull</em> and <em>push</em> operators. Essentially, any operator
which merges multiple inputs together must be a <em>pull</em> operator. In this case
that is the <code>\Reached Vertices/</code> merge and the join <code>V ⨝ E</code>. And similarly, any
operator which splits to multiple outputs must be a <em>push</em> operator, in this
case just the <code>/Reached Vertices\</code> split to the output.</p>
<p>Between the join and the split is where we go from pull to push. However from
the bottom <code>/Reached Vertices\</code> split back up the the <code>\Reached Vertices/</code>
merge we go from push to pull, which requires a handoff. The following code
creates a new handoff:</p>
<pre><code class="language-rust ignore">let (send_loop, recv_loop) = builder.make_edge::&lt;_, VecHandoff&lt;usize&gt;, _&gt;(&quot;loop&quot;);
</code></pre>
<p>The first <code>_</code> generic argument is the label type, then we have the
handoff type <code>VecHandoff&lt;usize&gt;</code> and the third specifies what wrapper type
(<code>Option</code>, <code>Single</code>, <code>Iter</code>) we will use to send to the handoff.</p>
<p>Lets take a look at the full code:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::builder::prelude::*;

pub fn main() {
    let mut builder = HydroflowBuilder::default();

    // Make the edges input.
    let (send_edges, recv_edges) =
        builder.add_channel_input::&lt;_, _, VecHandoff&lt;(usize, usize)&gt;&gt;(&quot;edge input&quot;);

    // Make the handoff for the loop.
    let (send_loop, recv_loop) = builder.make_edge::&lt;_, VecHandoff&lt;usize&gt;, _&gt;(&quot;loop&quot;);

    builder.add_subgraph(
        &quot;main&quot;,
        std::iter::once(0)
            .into_hydroflow()
            .chain(recv_loop.flatten())
            .map(|v| (v, ()))
            .join(recv_edges.flatten())
            .map(|(_old_v, (), new_v)| new_v)
            .pull_to_push()
            .tee(
                builder.start_tee().for_each(|v| println!(&quot;Reached: {}&quot;, v)),
                builder.start_tee().map(Some).push_to(send_loop),
            ),
    );

    let mut hf = builder.build();
    println!(&quot;{}&quot;, hf.generate_mermaid());

    println!(&quot;A&quot;);
    send_edges.give(Some((5, 10)));
    send_edges.give(Some((0, 3)));
    send_edges.give(Some((3, 6)));
    send_edges.flush();
    hf.tick();

    println!(&quot;B&quot;);
    send_edges.give(Some((6, 5)));
    send_edges.flush();
    hf.tick();
}
</code></pre></pre>
<pre><code class="language-txt">A
Reached: 3
Reached: 6
B
Reached: 5
Reached: 10
</code></pre>
<p>As for the code itself, we start out with the origin vertex, <code>0</code>:</p>
<pre><code class="language-rust ignore">std::iter::once(0)
    .into_hydroflow()
</code></pre>
<p>Now we introduce the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.PullSurface.html#method.chain"><code>.chain()</code> operator</a>,
which allows you to connect two pull-based operators into one, which returns
the individual elements of both original operators. The name comes from Rust's
<a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.chain"><code>Iterator::chain</code></a>
method, but unlike chain the elements will not neccesarily be ordered one
operator before the other. We'll probably change the name soon to emphasize
this.</p>
<pre><code class="language-rust ignore">    .chain(recv_loop.flatten())
</code></pre>
<p>This merges the <code>0</code> origin with any new reachable vertices from the loop
handoff.</p>
<p>Another way to connect two <code>pull-based</code> is with <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.PullSurface.html#method.join"><code>.join()</code></a>.
This acts like a SQL inner join. The inputs must have pair elements <code>(K, V1)</code>
and <code>(K, V2)</code>, and the operators joins them on equal keys and produces an
output of <code>(K, V1, V2)</code> elements. In this case we only want to join on <code>v</code> and
don't have any corresponding value, so we use <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.BaseSurface.html#method.map"><code>.map()</code></a>
to get <code>(v, ())</code> elements. Meanwhile the <code>recv_edges</code> are <code>(from, to)</code> pairs,
so our output is <code>(from, (), to)</code> where <code>from</code> and now <code>to</code> are reachable
vertices.</p>
<pre><code class="language-rust ignore">    .map(|v| (v, ()))
    .join(recv_edges.flatten())
    .map(|(_old_v, (), new_v)| new_v)
</code></pre>
<p>After the <code>pull_to_push()</code> we have a <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/surface/trait.PushSurface.html#method.tee"><code>.tee()</code> operator</a>,
which is similar to <code>.chain()</code> but instead of merging two pull-based operators
it outputs to multiple push-based operators. Each input element is cloned and
given to each of thw two outputs.</p>
<pre><code class="language-rust ignore">    .tee(
        builder.start_tee().for_each(|v| println!(&quot;Reached: {}&quot;, v)),
        builder.start_tee().map(Some).push_to(send_loop),
    )
</code></pre>
<p><a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/prelude/struct.HydroflowBuilder.html#method.start_tee"><code>builder.start_tee()</code></a>
creates a new &quot;disconnected&quot; output for teeing to. In this case, one branch
prints out all the reached vertices for the user, while the other branch pushes
reached vertices back up into the <code>send_loop</code> handoff.</p>
<p>Then the remaining code runs the graph with some example edge data. There's
also some extra code here, particularly <code>hf.generate_mermaid()</code> which lets us
generate a diagram rendered by <a href="https://mermaid-js.github.io/">Mermaid</a> showing
the structure of the graph:</p>
<pre class="mermaid">graph TD
  subgraph stratum0
    subgraph main1
      1.2[Chain] --&gt; 1.1[Map]
      1.11[Map] --&gt; Handoff_1[\loop/]
      1.8[Map] --&gt; 1.9[Tee]
      1.1[Map] --&gt; 1.0[Join]
      1.0[Join] --&gt; 1.13[/PullToPush\]
      1.3[Iter] --&gt; 1.2[Chain]
      1.4[Flatten] --&gt; 1.2[Chain]
      1.13[/PullToPush\] --&gt; 1.8[Map]
      Handoff_0[\edge input handoff/] --&gt; 1.6[Flatten]
      1.6[Flatten] --&gt; 1.0[Join]
      1.9[Tee] --&gt; 1.10[ForEach]
      Handoff_1[\loop/] --&gt; 1.4[Flatten]
      1.9[Tee] --&gt; 1.11[Map]
    end
  end
</pre>
<p>This is similar to the graph above but has a few more operators, making it look
more complex. In particular, the <code>loop</code> handoff is important as it is what
allows the subgraph to recurse to itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-un-reachability"><a class="header" href="#graph-un-reachability">Graph Un-Reachability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h2 id="dataflow-and-networking"><a class="header" href="#dataflow-and-networking">Dataflow and Networking</a></h2>
<p>Conventionally, dataflow systems provide a way to analyze and process data by
chaining functions (operators) together into pipelines. But with a change of
perspective, many computations can be represented as dataflow. Designing around
the flow of data naturally separates computation into easily parallelizable and
distributable pipelines.</p>
<p>Most dataflow systems provide opinionated mechanisms for running flows across
multiple machines. Hydroflow however aims to represent many more types of
computations besides just data processing. This includes networking protocols
like two-phase commit and Paxos. To this end, Hydroflow is unopinionated about
network communication. Additionally, Hydroflow provides the abstraction of only
a single node (single thread) of a system. To build up a distributed system,
the user must design each node to communicate with others as needed.</p>
<p>As development continues we will provide more utilities for common networking
use cases, but for now expect some manual management of IP addresses and
sockets.</p>
<h2 id="lattices"><a class="header" href="#lattices">Lattices</a></h2>
<h2 id="strata"><a class="header" href="#strata">Strata</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Hydroflow graphs are divided into two layers: the outer <em>scheduled layer</em> and
inner <em>compiled layer</em>.</p>
<p>The <a href="https://www.mingweisamuel.com/hydroflow/design_docs/2021-10_architecture_design_doc.html">Hydroflow Architecture Design Doc</a>
contains a more detailed explanation of this section. Note that some aspects of
the design doc are not implemented (e.g. early yielding) or may become out of
date as time passes.</p>
<h2 id="scheduled-layer"><a class="header" href="#scheduled-layer">Scheduled Layer</a></h2>
<p>The scheduled layer is dynamic: it stores a list of operators (or &quot;subgraphs&quot;)
as well as buffers (&quot;handoffs&quot;) between them. The scheduled layer chooses how
to schedule the operators (naturally), and when each operator runs it pulls
from its input handoffs and pushes to its output handoffs. This setup is
extremely flexible: operators can have any number of input or output handoffs
so we can easily represent any graph topology. However this flexibility comes
at a performance cost due to the overhead of scheduling, buffering, and lack
of inter-operator compiler optimization.</p>
<p>The <em>compiled layer</em> helps avoids the costs of the scheduled layer. We can
combine several operators into a <em>subgraph</em> which are compiled and optimized as
a single scheduled subgraph. The scheduled layer then runs the entire subgraph
as if it was one operator with many inputs and outputs. Note the layering here:
the compiled layer does not replace the scheduled layer but instead exists
within it.</p>
<h2 id="compiled-layer"><a class="header" href="#compiled-layer">Compiled Layer</a></h2>
<p>Rust already has a built-in API similar to dataflow: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code>s</a>.
When they work well, they work really well and tend to be as fast as for loops.
However, they are limited in the flow graphs they can represent. Each operator
in a <code>Iterator</code> takes ownership of, and <em>pulls</em> from, the previous operator.
Taking two iterators as <em>inputs</em> and merging them together (e.g. with
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain(...)</code></a>
or <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>.zip(...)</code></a>)
is natural and performant as we can <em>pull</em> from both. However if we want an
iterator to split into multiple <em>outputs</em> then things become tricky. <a href="https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee"><code>Itertools::tee()</code></a>
does just this by cloning each incoming item into two output buffers, but this
requires allocation and could cause unbounded buffer growth if the outputs are
not read from evenly.</p>
<p>However, if instead iterators were <em>pull</em>-based, where each operator owns one
or more <em>output</em> operators, then teeing is very easy, just clone each element
and push to (i.e. run) both outputs. So that's what we did, created push-based
iterators to allow fast teeing or splitting in the compiled layer.</p>
<p>Pull-based iterators can be connected to push-based iterators at a &quot;pivot&quot;
point. Together, this pull-to-push setup dictates the shape compiled subgraphs
can take. Informally, this is like the roots and leaves of a tree. Water flows
from the roots (the pull inputs), eventually all join together in the trunk
(the pull-to-push pivot), the split up into multiple outputs in the leaves.
We refer to this structure as an <em>in-out tree</em>.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/oaklandish_logo.jpg" alt="The Oaklandish Logo depicting the stylized roots, trunk, and branches of a tree." /></td></tr>
<tr><td style="text-align: center">The Oaklandish Logo.</td></tr>
</tbody></table>
<p>See <a href="./in-out_trees.html">Subgraph In-Out Trees</a> for more, including how to
convert a graph into in-out trees.</p>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<p>The two architectural layers can be interacted with through two corresponding
APIs. The <em>Surface API</em> provides a natural <code>Iterator</code>-like chaining syntax for
building compiled subgraphs and using them as scheduled operators.</p>
<p>Alternatively, the <em>Core API</em> requires interacting with handoffs directly and
doesn't provide any notion of chainable operators. You can use Rust <code>Iterator</code>s
or any other arbitrary Rust code to implement the operators.</p>
<p>We intend users to use the Surface API as it is much more friendly, but as
Hydroflow is in active development some operators might not be available in
the Surface API, in which case the Core API can be used instead. If you find
yourself in this sitation be sure to <a href="https://github.com/hydro-project/hydroflow/issues/new">submit an issue</a>!</p>
<p>Surface API code lives in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/builder/index.html"><code>hydroflow::builder</code></a>
while compiled push-based iterators live in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/compiled/index.html"><code>hydroflow::compiled</code></a>.
The Core API lives in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/index.html"><code>hydroflow::scheduled</code></a>,
mainly in methods on the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html"><code>Hydroflow</code> struct</a>.</p>
<h2 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h2>
<h2 id="handoffs"><a class="header" href="#handoffs">Handoffs</a></h2>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subgraph-in-out-trees"><a class="header" href="#subgraph-in-out-trees">Subgraph In-Out Trees</a></h1>
<p>Formally, we define an in-out-tree is the union of an
<em>in-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29#cite_ref-KorteVygen2012b_17-0"><em>anti-arborescence</em></a>)
with an <em>out-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29"><em>arborescence</em></a>)
where both trees share the same <em>root</em> node.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_tree.png" alt="A graph showing multiple nodes on the left all eventually feeding into a central pivot node, then continuing to multiple output nodes." /></td></tr>
<tr><td style="text-align: center">An <em>in-out tree</em> graph. Data flows from the green <em>pull</em> operators on the left, through the yellow pivot, and to the red <em>push</em> operators on the right.</td></tr>
</tbody></table>
<p>In this graph representation, each node corresponds to an operator, and the
edges direct the flow of data between operators.</p>
<h2 id="converting-graph"><a class="header" href="#converting-graph">Converting Graph</a></h2>
<p>Any graph can be partitioned into in-out trees. There is usually not a unique
partitioning, but it usually makes sense to create as few subgraphs as
possible.</p>
<p>Most graphs are pretty simple and can be partitioned with a bit of eye-balling.
But it is also not too tricky to find in-out tree subgraphs with a simple
coloring algorithm.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_example.png" alt="A random-looking directed graph with 8 nodes." /></td></tr>
<tr><td style="text-align: center">An example directed graph.</td></tr>
</tbody></table>
<p>To identify the in-out trees in an arbitrary directed graph, first identify any
nodes which have multiple inputs and outputs and mark these as pull-to-push
<em>pivots</em> (yellow in the example). Mark any nodes with multiple inputs (and a
single output) as <em>pull</em> (green) and any nodes with multiple outputs as <em>push</em>
(red).</p>
<p>In the example:</p>
<table><thead><tr><th>Pivots (yellow)</th><th>Pulls (green)</th><th>Pushes (red)</th></tr></thead><tbody>
<tr><td>1, 4</td><td>2</td><td>3, 7</td></tr>
</tbody></table>
<p>Finally any one-in-one-out nodes should be marked the same as their neighbors
(either green pull or red push). If we have green pull -&gt; red push that becomes
a yellow pivot. And if red push -&gt; green pull that becomes a blue handoff node,
and this is a division between subgraphs. Note that a subgraph can have a
handoff with itself; this forms a loop.</p>
<table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_partition.png" alt="The graph above converted and partitioned into two in-out trees." /></td></tr>
<tr><td style="text-align: center">The graph above converted and partitioned into two in-out trees. One is outlined in yellow and the other in red. For the corresponding Hydroflow graph, green nodes are <em>pull</em>, red nodes are <em>push</em>, yellow are <em>pivots</em>, and blue are <em>handoffs</em>.</td></tr>
</tbody></table>
<p>In the example partitioning above, some nodes have been split into multiple and
labelled with suffixes to make the pivots and handoffs more explicit.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
